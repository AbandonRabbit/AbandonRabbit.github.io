---
date: '2025-06-29T16:30:52+08:00'
draft: false
title: 'Web基础'
seriesOpened: true #s是否开启系列
series: ["JavaWeb"] #属于的系列 
series_order: 2  #系列编号
showSummary: true #是否显示摘要
summary: "" #摘要信息
tags: ["Web"]
Categories: ["Java"]
layoutBackgroundBlur: true #向下滚动主页时，是否模糊背景图。
layoutBackgroundHeaderSpace: true #在标题和正文之间添加空白区域间隔。
---

## HTTP 协议

超文本传输协议，默认使用 TCP/IP 传输，运行在应用层的一种**无状态协议**，使用请求、响应的模式，请求报文主要组成部分有HTTP 方法，请求资源路径，协议版本号，请求标头，请求体。响应报文主要包含：HTTP 协议版本号，状态码，状态信息，响应标头，响应体。

*无状态协议：* 客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。

**请求头信息**

| 请求头          | 含义                                                           |
| --------------- | -------------------------------------------------------------- |
| Host            | 表示请求的主机名 。                                            |
| User-Agent      | 浏览器版本。                                                   |
| Accept          | 表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有。 |
| Accept-Language | 表示浏览器偏好的语言，服务器可以据此返回不同语言的网页。       |
| Accept-Encoding | 表示浏览器可以支持的压缩类型，例如gzip, deflate等。            |
| Content-Type    | 请求主体的数据类型。                                           |
| Content-Length  | 数据主体的大小（单位：字节）。                                 |

### Cookie

存储在客户端浏览器，

如果响应头中有 `set-cookie` 会将这里面的数据写入 `cookie` ，在下一次的请求中，会将这个数据放入请求连接中。

**缺点**
1. 数据不安全。
2. 只能存储String类型的键值, 而且大小还有限制, 大部分浏览器支持cookie大约4kb, 而且每一个站点对cookie数量有限制, 一般都是20个左右。
3. 没有办法解决跨域问题,一旦跨域了, cookie携带不过去了, 其他服务器看不到数据了!!!。
4. 不支持移动端。

主要用来存储一些不太重要的偏爱设置的数据, 比较常用, 这些数据被盗窃无所谓, 丢失无所谓

### session

**原理**
第一次请求session的时候, 服务器会检查客户端是否携带了一个JSESSIONID的cookie，如果有，则会找到这个id对应的session对象，不会创建的新的session对象。如果没有，则会创建新的session对象, 并且将新的session对象的id, 以cookie的形式保存到浏览器中, 而且cookie的键是: JSESSIONID。

**面试题**
1. session存活的时间默认值: 30分钟。
2. session失效的时间: 一次会话,是因为cookie的时间默认是一次会话, 浏览器一旦关闭jsessionid的cookie会消失不见了。

**缺点**
1. session同样也不能跨域, session只能适用于简单的单体结构项目,而且还不能集群!!!
2. 不支持移动端。


**响应状态码**

| 状态码分类 | 说明         |
| ---------- | ------------ |
| 1xx        | 响应中       |
| 2xx        | 成功         |
| 3xx        | 重定向       |
| 4xx        | 客户端错误   |
| 5xx        | 服务器端错误 |

在浏览器按 `F12` 使用开发者工具可以查看发出的请求和响应。


## 三层架构

尽可能让每一个接口、类、方法的职责更单一些，从组成上看可以分为三个部分：
- 数据访问：负责业务数据的维护操作，包括增、删、改、查等操作。
- 逻辑处理：负责业务逻辑处理的代码。
- 请求处理、响应数据：负责，接收页面的请求，给页面响应数据。

在实际开发中分为：
- Controller：控制层。接收前端发送的请求，对请求进行处理，并响应数据。
- Service：业务逻辑层。处理具体的业务逻辑。
- Dao：数据访问层(Data Access Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。

## IOC&DI

**IOC**

控制反转，是一种设计原则，它将传统上由程序代码直接操控的对象调用权交给容器(如Spring框架)来管理，实现组件间的解耦。

容器负责创建和管理对象，对象被动接受依赖。  
IOC容器创建的对象称为bean对象。

**DI** (Dependency Injection, 依赖注入)

DI 是 IOC 的一种具体实现方式，容器在运行时动态地将依赖关系注入到组件中。

主要目的，减少类与类之间的依赖，自动生成构造器、 get 和 set 方法，无需在手动创建对象。

在实现类加上 `@Component` 注解，就代表把当前类产生的对象交给IOC容器管理。

### bean冲突

同一个类型有多个 bean

解决方法一：
    我们可以结合 `@Autowired` 和 `@Qualifier("对象名")` 进行组合使用完成类型加名字确定bean的唯一!!!

解决方法二：
    `@Resource(name="名字")` 按照名字注入

解决方法三：
    `@Primary` 优先使用哪个bean

### 在三层架构中的使用


| 注解          | 位置                                              |
| ------------- | ------------------------------------------------- |
| `@Component`  | 不属于以下三类时，用此注解                        |
| `@Controller` | 标注在控制层类上                                  |
| `@Service`    | 标注在业务层类上                                  |
| `@Repository` | 标注在数据访问层类上（由于与mybatis整合，用的少） |

## 附录

### 常见的响应状态码

| 状态码 | 英文描述                        | 解释                                                                                               |
| ------ | ------------------------------- | -------------------------------------------------------------------------------------------------- |
| 200    | OK                              | 客户端请求成功，即处理成功，这是我们最想看到的状态码。                                             |
| 302    | Found                           | 指示所请求的资源已移动到由Location响应头给定的 URL，浏览器会自动重新访问到这个页面。               |
| 304    | Not Modified                    | 告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向。           |
| 400    | Bad Request                     | 客户端请求有语法错误，不能被服务器所理解。                                                         |
| 403    | Forbidden                       | 服务器收到请求，但是拒绝提供服务，比如：没有权限访问相关资源。                                     |
| 404    | Not Found                       | 请求资源不存在，一般是URL输入有误，或者网站资源被删除了。                                          |
| 405    | Method Not Allowed              | 请求方式有误，比如应该用GET请求方式的资源，用了POST。                                              |
| 428    | Precondition Required           | 服务器要求有条件的请求，告诉客户端要想访问该资源，必须携带特定的请求头。                           |
| 429    | Too Many Requests               | 指示用户在给定时间内发送了太多请求（“限速”），配合 Retry-After(多长时间后可以请求)响应头一起使用。 |
| 431    | Request Header Fields Too Large | 请求头太大，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。   |
| 500    | Internal Server Error           | 服务器发生不可预期的错误。服务器出异常了，赶紧看日志去吧。                                         |
| 503    | Service Unavailable             | 服务器尚未准备好处理请求，服务器刚刚启动，还未初始化好。                                           |

