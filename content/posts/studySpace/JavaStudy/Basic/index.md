---
date: '2025-06-04T17:24:11+08:00'
draft: false
title: '基本数据类型、流程控制'
seriesOpened: true #s是否开启系列
series: ["Java学习笔记"] #属于的系列 
series_order: 1  #系列编号
showSummary: true #是否显示摘要
summary: "" #摘要信息
tags: ["Java基础"]
Categories: ["Java","学习笔记"]
layoutBackgroundBlur: true #向下滚动主页时，是否模糊背景图。
layoutBackgroundHeaderSpace: true #在标题和正文之间添加空白区域间隔。
---

运行命令  
~~~
java <文件名>
~~~

编译命令  
~~~
javac <文件名>
~~~


新建项目步骤：
工程 -> 模块 -> 包 -> 类

模块名称一般为域名倒写。


## 基本数据类型

整数：byte(一个字节)、short(两个字节)、int（四个字节）、long（八个字节）  

小数：floot（四个字节）、double（八个字节）

字符：char（两个字节）

布尔：boolean（一个字节）

变量定义：

~~~
数据类型 变量名 = 初始值;
~~~

## 方法&运算符

### 方法

~~~
修饰符 返回值类型 方法名(形参列表) {
方法体代码(需要执行的功能代码) 
return 返回值;
}
~~~

*无返回值的方法中可以直接通过单独的return;立即结束当前方法的执行。*

**方法重载**：方法名相同，参数列表不同。

### 类型转换

1. **自动类型转换**类型范围小的变量，可以直接赋值给类型范围大的变量。
2. **强制类型转换**大范围类型的变量直接赋值给小范围类型的变量，需要通过强制类型转换来实现。强制类型转换可能造成数据丢失。
3. **表达式的自动类型提升**小范围类型的变量会自动转换成表达式中较大范围的类型，再参与运算。

### 运算符

基本算数运算符包括+（加）、-（减）、*（乘）、/（除）、%（取余）。

自增（++）和自减（--）运算符

扩展赋值运算符包括+=、-=、*=、/=、%=

关系运算符包括 >（大于）、>=（大于等于）、<（小于）、<=（小于等于）、==（等于）、!=（不等于），用于判断数据是否满足条件，最终返回布尔类型的值（true或者false）。

三元运算符  格式：条件表达式? 值1 : 值2。

逻辑运算符  &（逻辑与）、  &&（短路与）、  |（逻辑或）、  ||（短路或）、  !（逻辑非）、  ^（逻辑异或）。

## 流程控制

### 分支

**if 分支**

~~~
if (条件表达式) {
    代码;
}

if (条件) {
    语句体 1;
} else {
    语句体 2;
}

if (条件 1){
    语句体 1;
} else if (条件 2){
    语句体 2;
} else if (条件 3){
    语句体 3;
}...
 else{
    语句体 n +1;
}
~~~

**switch 分支**

~~~
switch(表达式){
    case 值1:
        语句体1;
        break;
    case 值2:
        语句体1;
        break;
    ...
    default:
        语句体n;
        break;    
}
~~~

### 循环

**for 循环**

~~~
for (初始化语句; 循环条件; 迭代语句) {
    循环体语句(重复执行代码);
}
~~~

**while 循环**

~~~
while (循环条件) {
    循环体语句(重复执行代码);
    迭代语句;
}
~~~


**do - while 循环**

先执行循环体再判断条件，至少执行一次循环体。

~~~
do {
    循环体语句;
    迭代语句;
} 
~~~

**死循环**：常用于服务器程序持续监听、后台任务持续运行场景，但使用需谨慎，确保有合理退出机制，防系统资源耗尽崩溃。如服务器监听客户端连接请求，循环等待并处理连接，同时设心跳检测或管理员指令停止机制。

## 数组

占用连续的存储空间

- 静态初始化
  ~~~
  完整格式：
  数据类型[] 数组名 = new 数据类型 []{元素 1，元素 2，元素 3… }; 

  简化格式：
  数据类型[] 数组名 = {元素 1，元素 2，元素 3，… }; 
  ~~~

- 动态初始化：
  ~~~
  数据类型 [][] 数组名 = new 数据类型 [长度 1][长度 2]; 
  ~~~

获取长度 ```arr.length```

**二维数组**

~~~
完整格式: 
数据类型 [][] 数组名 = new 数据类型 [][]{
 {元素1,元素2 ...},
 {元素2,元素3...},
 {元素4,元素5...}
}; 
简化格式: 
数据类型 [][] 数组名 = {
 {元素1,元素2 ...},
 {元素2,元素3...},
 {元素4,元素5...}
}; 
~~~

## 字符串

两种初始化方式

~~~java
String s1 = "Hello";  
String s2 = "Hello";  

String s3 = new String("Hello");  
String s4 = new String("Hello");  
~~~

**对比**
1. 直接赋值 `=`
   - 节省内存（复用常量池中的字符串）  
   - 性能更高（避免重复创建对象）  
    **底层机制**
    - 检查字符串常量池（String Pool），如果 `"Hello"` 已存在，则 `s2` 直接引用池中的对象。
    - `s1` 和 `s2` 指向同一个内存地址（`s1 == s2` 返回 `true` 。
2. new String()
   - 内存浪费（每次 new 都会创建新对象）  
   - 性能较低（无常量池优化）  
   **底层机制**
   - 强制在堆内存中创建新对象，即使 `"Hello"` 已在常量池中存在。
   - `s3` 和 `s4` 指向不同的内存地址（`s3 == s4` 返回 `false`）。

> 在 java 6 之前都是存储在方法区，并且是固定大小的。从 java 7 开始常量池移入堆内存，哈希表，可动态扩展。移入堆之后，允许被 GC 回收，避免永久代内存溢出。

一些**面试题**
> Q： `String s1 = new String("Hello");` 这段代码创建了几个对象？
> 
> A:  1 或 2 个：
> 1. 如果常量池没有 "Hello"，先创建字面量对象（入池），再 new 堆对象 → 共 2 个。
> 2. 如果常量池已有 "Hello"，只 new 堆对象 → 共 1 个。
>
> Q： `String s = "a" + "b"` 创建几个对象？
> 
> A：1 个（编译期优化为 "ab"，直接存入常量池）。
>
> Q：`String s = new String("a") + new String("b")` 创建几个对象？
> 
> A：堆中：2 个 "a" 和 "b" 的 String 对象 + 1 个 "ab" 的 StringBuilder 最终结果 → 至少 3 个，常量池："a" 和 "b" 的字面量对象（如果之前不存在）→ 最多 +2 个。

| 方法名                                           | 描述                                                      |
| ------------------------------------------------ | --------------------------------------------------------- |
| `int length();`                                  | 获取字符串的长度                                          |
| `char charAt(int index); `                       | 根据索引获取对应的字符                                    |
| `char[] toCharArray();`                          | 将字符串转成字符数组                                      |
| `boolean equals(Object obj)`                     | 比较字符串的内容                                          |
| `boolean equalsIgnoreCase(String str);`          | 忽略大小写比较字符串内容                                  |
| `String substring(int start); `                  | 从start位置截取到末尾, 原串不变, 返回新串                 |
| `String substring(int start,int end); `          | 从start位置截取到end-1, 原串不变, 返回新串                |
| `String replace(String oldStr, String newStr); ` | 可以将字符串中所有的oldStr替换成newStr, 原串不变返回新串  |
| `boolean startsWith(String start); `             | 判断字符串是否以start开头                                 |
| `boolean endsWith(String end); `                 | 判断字符串是否以end结尾                                   |
| `boolean contains(String str); `                 | 判断字符串是否包含另外一个字符串                          |
| `int indexOf(String str); `                      | 查询str在字符串第一次出现的位置, 返回是首字母出现的位置   |
| `int lastIndexOf(String str)  `                  | 查询str在字符串最后一次出现的位置, 返回是首字母出现的位置 |
| `String toUpperCase();`                          | 将字符串的小写都变成大写, 原串不变,返回新串               |
| `String toLowerCase();`                          | 将字符串的大写都变成小写, 原串不变,返回新串               |
| `String[] split(String str)  `                   | 按照切割点进行字符串切割, 将结果封装数组中返回            |