---
date: '2025-05-14T09:08:14+08:00'
draft: false
title: 'Java基础'
seriesOpened: false #s是否开启系列
# series: [""] #属于的系列 
# series_order: 0  #系列编号
showSummary: ["Java基础"] #摘要信息
tags: ["Java基础"]
Categories: ["Java","学习笔记"]
layoutBackgroundBlur: false #向下滚动主页时，是否模糊背景图。
layoutBackgroundHeaderSpace: true #在标题和正文之间添加空白区域间隔。
---


运行命令  
~~~
java <文件名>
~~~

编译命令  
~~~
javac <文件名>
~~~


新建项目步骤：
工程 -> 模块 -> 包 -> 类

模块名称一般为域名倒写。


## 基本数据类型

整数：byte(一个字节)、short(两个字节)、int（四个字节）、long（八个字节）  

小数：floot（四个字节）、double（八个字节）

字符：char（两个字节）

布尔：boolean（一个字节）

变量定义：

~~~
数据类型 变量名 = 初始值;
~~~

## 方法&运算符

### 方法

~~~
修饰符 返回值类型 方法名(形参列表) {
方法体代码(需要执行的功能代码) 
return 返回值;
}
~~~

*无返回值的方法中可以直接通过单独的return;立即结束当前方法的执行。*

**方法重载**：方法名相同，参数列表不同。

### 类型转换

1. **自动类型转换**类型范围小的变量，可以直接赋值给类型范围大的变量。
2. **强制类型转换**大范围类型的变量直接赋值给小范围类型的变量，需要通过强制类型转换来实现。强制类型转换可能造成数据丢失。
3. **表达式的自动类型提升**小范围类型的变量会自动转换成表达式中较大范围的类型，再参与运算。

### 运算符

基本算数运算符包括+（加）、-（减）、*（乘）、/（除）、%（取余）。

自增（++）和自减（--）运算符

扩展赋值运算符包括+=、-=、*=、/=、%=

关系运算符包括 >（大于）、>=（大于等于）、<（小于）、<=（小于等于）、==（等于）、!=（不等于），用于判断数据是否满足条件，最终返回布尔类型的值（true或者false）。

三元运算符  格式：条件表达式? 值1 : 值2。

逻辑运算符  &（逻辑与）、  &&（短路与）、  |（逻辑或）、  ||（短路或）、  !（逻辑非）、  ^（逻辑异或）。

## 流程控制

### 分支

**if 分支**

~~~
if (条件表达式) {
    代码;
}

if (条件) {
    语句体 1;
} else {
    语句体 2;
}

if (条件 1){
    语句体 1;
} else if (条件 2){
    语句体 2;
} else if (条件 3){
    语句体 3;
}...
 else{
    语句体 n +1;
}
~~~

**switch 分支**

~~~
switch(表达式){
    case 值1:
        语句体1;
        break;
    case 值2:
        语句体1;
        break;
    ...
    default:
        语句体n;
        break;    
}

~~~

### 循环

**for 循环**

~~~
for (初始化语句; 循环条件; 迭代语句) {
    循环体语句(重复执行代码);
}

~~~

**while 循环**

~~~
while (循环条件) {
    循环体语句(重复执行代码);
    迭代语句;
}

~~~


**do - while 循环**

先执行循环体再判断条件，至少执行一次循环体。

~~~
do {
    循环体语句;
    迭代语句;
} 

~~~

**死循环**：常用于服务器程序持续监听、后台任务持续运行场景，但使用需谨慎，确保有合理退出机制，防系统资源耗尽崩溃。如服务器监听客户端连接请求，循环等待并处理连接，同时设心跳检测或管理员指令停止机制。

## 数组

~~~
完整格式：
数据类型 [] 数组名 = new 数据类型 []{元素 1，元素 2，元素 3… }; 

简化格式：
数据类型 [] 数组名 = {元素 1，元素 2，元素 3，… }; 

~~~

获取长度 ```arr.length```

**二维数组**

~~~
完整格式: 
数据类型 [][] 数组名 = new 数据类型 [][]{
 {元素1,元素2 ...},
 {元素2,元素3...},
 {元素4,元素5...}
}; 
简化格式: 
数据类型 [][] 数组名 = {
 {元素1,元素2 ...},
 {元素2,元素3...},
 {元素4,元素5...}
}; 

~~~

- 动态初始化：
  ~~~
  数据类型 [][] 数组名 = new 数据类型 [长度 1][长度 2]; 
  
  ~~~

## 面向对象入门

**1. 类基本语法及定义**

~~~
public class 类名 {
    //构造器
    //成员变量
    //成员方法
}

~~~

**2. 创建对象**

~~~
类名 对象名 = new 类名();

~~~

**3. 访问对象属性和方法**

~~~
对象名.方法名

对象名。属性名

~~~


**4. 构造器**

构造函数一般用于结合new关键字创建对象时初始化成员变量用的

类如果没有手动设置构造函数, 会默认自带无参构造器。

如果定义了有参构造器，默认无参构造器会消失，若需要则需手动添加。

~~~
修饰符  类名(参数列表){

}

~~~

> 注意事项:
> 1. 构造函数的名字和类名必须一致
> 2. 构造函数不能返回值类型, 连void都不能有
> 3. 构造函数可以重载

## 面向对象 static 、继承

### static

static是一个修饰符,可以修饰成员变量和成员方法等

**修饰变量**

有static修饰，属于类，在内存中只有一份，被类的所有对象共享。  

访问类变量的格式为: 类名.静态变量（推荐）或对象.静态变量（不推荐）。

**修饰方法**

属于类，访问类方法的格式: 可以直接用类名访问（推荐），也可以用对象访问（不推荐）。

> 静态方法主要用来做工具类，调用方便，代码复用性高

{{< alert >}}
1. 静态方法中可以直接访问静态成员，不可以直接访问实例成员。
2. 实例方法中既可以直接访问静态成员，也可以直接访问实例成员。
3. 实例方法中可以出现this关键字，静态方法中不可以出现this关键字。
{{< /alert >}}

### 继承

提高代码重用性，减少重复代码书写。

~~~
public class 子类 extends 父类{

} 

~~~

- 子类能继承父类的非私有成员（成员变量、成员方法）。  
- 子类的对象由子类和父类共同完成。

### 权限修饰符

限制类中成员（成员变量、成员方法、构造器）的访问范围。

- private：只能本类访问。  
  缺省（默认，无修饰符）：本类、同一个包中的类可访问。
- protected：本类、同一个包中的类、子孙类中可访问。
- public：任意位置可访问。



| 修饰符    | 本类 | 本包不同类 | 不同包的子类 | 不同包的无关类 |
| --------- | ---- | ---------- | ------------ | -------------- |
| public    | √    | √          | √            | √              |
| protected | √    | √          | √            |                |
| 缺省      | √    | √          |              |                |
| private   | √    |            |              |                |

### 继承的特点


1. 就近原则：
在子类方法中访问其他成员，先在子类局部范围找，然后子类成员范围找，接着父类成员范围找，若父类范围找不到则报错。
2. 单继承模式：
Java 中一个类只能继承一个直接父类
3. 多层继承：
Java 不支持多继承，但支持多层继承。
4. 祖宗类：
Java 中所有类要么直接继承Object，要么默认继承Object，要么间接继承Object，Object是所有类的祖宗类。
5. 子类访问父类成员：
若子父类中出现重名成员，优先使用子类的，若要在子类中使用父类的，
可通过super关键字指定访问父类成员
格式为: （super.父类成员变量/super.父类成员方法）。

### 方法重写

重写父类的方法，需要方法名、参数列表保证一致。

建议使用@Override注解，可检查重写格式是否正确且提高代码可读性。

- 子类重写父类方法时，访问权限必须大于或等于父类该方法的权限（public>protected> 缺省）。
- 重写的方法返回值类型必须与被重写方法的返回值类型一样或范围更小。
- 私有方法、静态方法不能被重写，否则报错。

### 子类构造器？？？

子类的全部构造器都会先调用父类的构造器，再执行自己。