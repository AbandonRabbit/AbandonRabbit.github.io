---
date: '2025-06-04T17:37:07+08:00'
draft: false
title: '面向对象'
seriesOpened: false #s是否开启系列
series: ["java学习笔记"] #属于的系列 
series_order: 2  #系列编号
showSummary: true #摘要信息
summary: "" #摘要信息
tags: ["Java基础"]
Categories: ["Java","学习笔记"]
layoutBackgroundBlur: true #向下滚动主页时，是否模糊背景图。
layoutBackgroundHeaderSpace: true #在标题和正文之间添加空白区域间隔。
---

## 面向对象 static 、继承

### static

static是一个修饰符,可以修饰成员变量和成员方法等

**修饰变量**

有static修饰，属于类，在内存中只有一份，被类的所有对象共享。  

访问类变量的格式为: 类名.静态变量（推荐）或对象.静态变量（不推荐）。

**修饰方法**

属于类，访问类方法的格式: 可以直接用类名访问（推荐），也可以用对象访问（不推荐）。

使用 static 修饰的变量或者放啊随着类的加载而被加载到堆的静态区，变量被所有对象共享。

> 静态方法主要用来做工具类，调用方便，代码复用性高

{{<alert>}}
1. 静态方法中可以直接访问静态成员，不可以直接访问实例成员。
2. 实例方法中既可以直接访问静态成员，也可以直接访问实例成员。
3. 实例方法中可以出现this关键字，静态方法中不可以出现this关键字。
4. 使用 static 修饰的成员不能被继承。
{{</alert>}}

## 继承

提高代码重用性，减少重复代码书写。

不能循环继承。

~~~
public class 子类 extends 父类{

} 
~~~

- 子类能继承父类的非私有成员（成员变量、成员方法）。
- 子类的对象由子类和父类共同完成。

```super``` 在子类中访问父类的属性或方法。

~~~
super.父类方法
~~~

### 权限修饰符

限制类中成员（成员变量、成员方法、构造器）的访问范围。

- `private`：只能本类访问。  
  缺省（默认，无修饰符）：本类、同一个包中的类可访问。
- `protected`：本类、同一个包中的类、子孙类中可访问。
- `public`：任意位置可访问。



| 修饰符    | 本类 | 本包不同类 | 不同包的子类 | 不同包的无关类 |
| --------- | ---- | ---------- | ------------ | -------------- |
| public    | √    | √          | √            | √              |
| protected | √    | √          | √            |                |
| 缺省      | √    | √          |              |                |
| private   | √    |            |              |                |

### 继承的特点

1. 就近原则：
在子类方法中访问其他成员，先在子类局部范围找，然后子类成员范围找，接着父类成员范围找，若父类范围找不到则报错。
2. 单继承模式：
Java 中一个类只能继承一个直接父类
3. 多层继承：
Java 不支持多继承，但支持多层继承。
4. 祖宗类：
Java 中所有类要么直接继承 Object ，要么默认继承 Object ，要么间接继承 Object ， Object 是所有类的祖宗类。
5. 子类访问父类成员：
若子父类中出现重名成员，优先使用子类的，若要在子类中使用父类的，
可通过 `super` 关键字指定访问父类成员  
格式为: （`super.父类成员变量/super.父类成员方法`）。

### 方法重写

重写父类的方法，需要方法名、参数列表保证一致。

建议使用@Override注解，可检查重写格式是否正确且提高代码可读性。

- 子类重写父类方法时，访问权限必须大于或等于父类该方法的权限（public > protected > 缺省）。
- 重写的方法返回值类型必须与被重写方法的返回值类型一样或范围更小。
- 私有方法、静态方法不能被重写，否则报错。

### 子类构造器

~~~java
super(value1，value2，...)
~~~

> 在子类的构造器里面使用，必须写在第一行。
> 
> 括号里面可以加参数，会自动匹配相应参数的构造器
> 
> 如果父类没有无参构造器，则子类必须显示使用 super( value... )。


~~~java
this(value1，value2，...)
~~~

> 在当前类的构造器里面使用，调用当前类的构造器，必须卸载第一行。
> 
> 可以加入参数，自动匹配相应参数的构造器。
> 
> 不能和 `super()` 一起使用

## 多态

在继承 / 实现情况下的一种现象，表现为对象多态、行为多态。

一般表现形式为父类类型指向一个子类的对象。

在多态下，只能访问父类的内容。如果子类对父类的方法重写，那么会访问到重写之后的方法。

### 抽象类

关键字 ` abstract `

**一、核心特性**

1. 抽象类（abstract class）
   - 不能直接实例化（必须通过子类继承）。
   - 可以包含 抽象方法（无实现）和 具体方法（有实现）。
   - 可以定义 成员变量、构造方法、静态方法。

2. 抽象方法（abstract method）
   - 只有声明，没有方法体（以分号 ; 结尾）。
   - 必须在子类中被重写（除非子类也是抽象类）。

3. 设计目的
   - 作为模板，强制子类实现特定行为（如 `Animal` 抽象类要求子类实现 eat()）。

{{<alert>}}
**注意事项**
{{</alert>}}
1. 构造方法的存在意义
   - 虽然抽象类不能实例化，但子类构造方法会隐式调用父类构造方法（通过 `super()` ）。
   - 可用于初始化抽象类的成员变量。
2. 与 `final` 冲突
   - `abstract` 和 `final` 不能共用：
     - `final` 类不能被继承 → 与 `abstract` 需要继承矛盾。
     - `final` 方法不能被重写 → 与 `abstract` 必须重写矛盾。

**关键字 `final`**

`final` 用于声明不可变的变量、方法或类，具体作用如下：

1. `final` 变量（常量）
   - 基本类型：值不可变（如 `final int x = 10;`）。
   - 引用类型：引用不可变（但对象内部状态可能可变）。

2. `final` 方法
   - 不能被子类重写（但可以重载）。
   - 适用于不希望子类修改的方法（如模板方法模式中的关键步骤）。

3. `final` 类
   - 不能被继承（如 `String`、`Integer` 等不可变类）。
   - 适用于安全性要求高的类（防止恶意子类化）。

{{<alert>}}
**注意事项**
{{</alert>}}

1. `final` 变量的初始化时机
   - 成员变量：必须在声明时、构造方法中或初始化块中赋值。
    ~~~java
    final int a;  
    public MyClass() { a = 10; } // 合法  
    ~~~
   - 局部变量：只需在使用前赋值一次。
    ~~~java
    final int b;  
    b = 20; // 合法 法      
    ~~~

2. `final` 与不可变对象
   
- `final` 只能保证引用不变，若对象本身可变（如 `List`），仍需通过其他方式（如 `Collections.unmodifiableList()`）实现真正不可变。
  
3. `final` 参数
   - 方法参数被 `final` 修饰后，不能在方法内重新赋值（但不会影响调用方传入的变量）。
    ~~~java
    void foo(final int x) {  
        x = 10; // 编译错误！  
    }  
    ~~~
4. `final` 与性能优化
   - JVM 可能对 `final` 变量进行内联优化（直接替换为常量值）。
   - 多线程环境下， `final` 变量能保证初始化安全（无需额外同步）。

5. `final` 与其他关键字的冲突
   - abstract： `final` 方法不能被重写，`abstract` 方法必须被重写 → 互斥。
   - volatile： `final` 变量本身线程安全，无需再加 `volatile`。

### 多态下的类型转换

必须是一个还原操作, 否则会出现 `ClassCastException` 类型转换异常

可以以使用 `instanceof` 方法进行检测，该方法会返回一个 boolean 值，表示是否为这个类型。